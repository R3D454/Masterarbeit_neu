// --------------------------------------------------------
// Code generated by Papyrus C++
// --------------------------------------------------------

#define Model_object_BODY

/************************************************************
 object class body
 ************************************************************/


// include associated header file
#include "Model/object.h"

// Derived includes directives
#include "Model/Equipment.h"

#define PORT 3000

#define BUFSIZE 500



namespace Model {

int object::Counter = 0;
int object::CounterFriendly = 0;
int object::CounterEnemy = 0;
int object::CounterNeutral = 0;


// static attributes (if any)
Geocentric earth(Constants::WGS84_a(), Constants::WGS84_f());

/**
 *
 * @param name
 */
void object::setName(std::string /*in*/name) {
	Name = name;
}

/**
 *
 * @return
 */
std::string object::getName() {
	return Name;
}

/**
 *
 * @return
 */
void object::generateEntityID() {
}

/**
 *
 * @param name
 */
void object::setCountry(std::string /*in*/name) {
	Country = name;
}

/**
 *
 * @return
 */
std::string object::getCountry() {
	return Country;
}

/**
 *
 * @param number
 */
void object::setProtocolVersion(int /*in*/number) {
	ProtocolVersion = number;
}

/**
 *
 * @return
 */
int object::getProtocolVersion() {
	return ProtocolVersion;
}

/**
 *
 * @param name
 */
void object::SetDomain(std::string /*in*/name) {
	Domain = name;
}

/**
 *
 * @return
 */
std::string object::getDomain() {
	return Domain;
}

/**
 *
 * @param pos
 */
void object::setPosition(double lat,double lon,double height) {

Position.lat = lat;
Position.lon = lon;
Position.height_above_geoid = height;
Vector3D local_positionXYZ;
earth.Forward(Position.lat, Position.lon, Position.height_above_geoid, local_positionXYZ.x, local_positionXYZ.y, local_positionXYZ.z);
object::setPositionXYZ(local_positionXYZ);
}

/**
 *
 * @return position
 */
position_dec object::getPosition() {
	return Position;
}

/**
 *
 * @param value
 */
void object::setKind(std::string /*in*/k) {
	Kind = k;
}

/**
 *
 * @return value
 */
std::string object::getKind() {
	return Kind;
}

void object::makeStdDISPDU(DIS::Vector3Float velo,DIS::Orientation orie){
DISUnit.setProtocolVersion(6);
DISUnit.setExerciseID(0);
// if(EntityIDisSet = false){
DIS::EntityID DISunit_entity_id;
DISunit_entity_id.setSite( 0 );
DISunit_entity_id.setApplication( 1 );
int ForceID;
if (Membership == "Other") {
	DISunit_entity_id.setEntity( 0 );
	ForceID = 0;
} else if(Membership == "Friendly") {
	DISunit_entity_id.setEntity( (1 + CounterFriendly * 3)-3 );
	ForceID = ((1 + CounterFriendly * 3)-3);


}else if(Membership == "Enemy"){
	DISunit_entity_id.setEntity( (2 + CounterEnemy * 3)-3 );
	ForceID = ((2 + CounterEnemy * 3)-3);
} else {
	DISunit_entity_id.setEntity( (3 + CounterNeutral * 3)-3);
	ForceID = ((3 + CounterNeutral * 3)-3);

}



DIS::EntityType DISType;
DISType.setEntityKind(DIS_EntityType.Kind);
DISType.setDomain(DIS_EntityType.Domain);
DISType.setCountry(DIS_EntityType.Country);
DISType.setCategory(DIS_EntityType.Category);
DISType.setSubcategory(DIS_EntityType.SubCategory);
DISType.setSpecific(0);
DISType.setExtra(0);

if (EntityIDisSet == false) {
	DISUnit.setEntityID(DISunit_entity_id);
	DISUnit.setEntityType(DISType);
	DISUnit.setForceId(ForceID);
	EntityIDisSet = true;
// std::cout << "false" << '\n';
	}

// EntityIDisSet = true;
// }
DIS::Vector3Double DISPosition;
DISPosition.setX(PositionXYZ.x);
DISPosition.setY(PositionXYZ.y);
DISPosition.setZ(PositionXYZ.z);

DISUnit.setEntityLocation(DISPosition);
DISUnit.setEntityLinearVelocity(velo);
DISUnit.setEntityOrientation(orie);
}

/**
 *
 * @param location
 * @param orientation
 * @param equipment
 * @param category
 * @param subCategory
 */
// void object::convertToDIS(undefined /*in*/location, undefined /*in*/orientation,
// 		Equipment /*in*/equipment, int /*in*/category, int /*in*/subCategory) {
// }
	void object::setDIS_EntityType_Variables(DIS_EntityType_Variables entitytype){
	DIS_EntityType = entitytype;
	}

	DIS_EntityType_Variables object::getDIS_EntityType_Variables(){
			return DIS_EntityType;
	}

	void object::setPositionXYZ(Vector3D positionXYZ){
		PositionXYZ = positionXYZ;
	}

	Vector3D object::getPositionXYZ(){
  	return PositionXYZ;
	}

	void object::sendToNetwork(char DST[15]){
		DIS::DataStream buffer( DIS::BIG );
		char buf[BUFSIZE];
		DISUnit.setLength( DISUnit.getMarshalledSize());
		DISUnit.marshal(buffer);
		memset(buf,0,BUFSIZE);
		memcpy(buf,&buffer[0],buffer.size());
		send_data( buf, buffer.size(), DST, PORT );
		buffer.clear();

	}

	void object::addArticulationParameter(std::vector<DIS::ArticulationParameter> /*in */ params){
		DISUnit.setArticulationParameters(params);

		}

		DIS::EntityStatePdu object::getDISPdu(){
			return DISUnit;
		}

		void object::incrementCounter(){
			Counter++;
		}
		void object::decrementCounter(){
			Counter--;
		}
		int object::getCounter(){
			return Counter;
		}

		void object::incrementCounterFriendly(){
			CounterFriendly++;
		}
		void object::decrementCounterFriendly(){
			CounterFriendly--;
		}
		void object::incrementCounterEnemy(){
			CounterEnemy++;
		}
		void object::decrementCounterEnemy(){
			CounterEnemy--;
		}
		void object::incrementCounterNeutral(){
			CounterNeutral++;
		}
		void object::decrementCounterNeutral(){
			CounterNeutral--;

		}

		std::string object::getMembership(){
			return Membership;
		}

	  void object::setMembership(std::string membership){
			if (membership =="Friendly" || membership =="Enemy"|| membership =="Neutral"|| membership =="Other") {
				if (membership =="Friendly") {
					Membership = membership;
					CounterFriendly++;
				} else if(membership =="Enemy"){
					Membership = membership;
					CounterEnemy++;
				}else if (membership =="Neutral"){
					Membership = membership;
					CounterNeutral++;
				} else  {
					Membership = membership;
				}

			} else {
				std::cout << "Membership can only be 'Enemy','Friendly' or 'Neutral'" << '\n';
				std::cout << "Friendly = 1" << '\n';
				std::cout << "Enemy = 2" << '\n';
				std::cout << "Neutral = 3" << '\n';
				std::cout << "Other = 4" << '\n';


				int mem;
				std::cin >> mem;

				switch (mem) {
					case 1: Membership = "Friendly";
					CounterFriendly++;
					break;
					case 2:	Membership = "Enemy";
					CounterEnemy++;

					break;
					case 3:	Membership = "Neutral";
					CounterNeutral++;

					break;
					case 4:	Membership = "Other";
					break;
					default:	std::cout << "false input" << '\n';
					break;
				}
			}

		}


} // of namespace Model

/************************************************************
 End of object class body
 ************************************************************/
