\chapter{Einleitung}\label{Einleitung}
\onehalfspacing
In den letzten Jahrzehnten spielten Simulatoren in zivilen und militärischen Bereichen eine immer größere Rolle. Durch sie konnte die Ausbildung von Piloten aber auch von normalen Fahrzeugbesatzungen und Soldaten verbessert werden. Durch den Einsatz von Simulationen können Szenarien in sicherer Umgebung geübt werden. Neben der Ausbildung von Personal können in Simulationen auch Fahrzeuge oder Geräte getestet werden, ohne diese konstruieren zu müssen. 
Um die Ausbildung oder das Simulieren von Fahrzeugen noch effizienter zu gestalten, kam die Forderung auf, einzelne Simulationen miteinander zu vernetzten und interagieren zu lassen. Das Vernetzen von Simulationen integriert zum Beispiel Flugsimulatoren und Panzersimulatoren in ein Szenario und lässt diese zusammen interagieren. 
Dafür wurden verschiedene Standards festgelegt, wie zum Beispiel \ac{dis} und \ac{hla}\\ 
Ziel dieser Arbeit war es, eine grundlegende Klassenhierarchie zu erstellen, die es ermöglicht, verschiedene Objekte zu simulieren. Dabei sollte es die Möglichkeit geben, den Objekten verschiedene Ausrüstung, wie Waffen und Sensoren, zuzuordnen, welche ebenfalls simuliert werden sollten. Es sollte dann die Möglichkeit geben, das simulierte Objekte in den \ac{dis} Standard zu übersetzten und an andere Simulationen zu schicken.  \\
Dafür wird zunächst C++ und deren Unterschied zu C beschrieben. Diese Programmiersprache ist eine Sprache, die objektorientiertes Programmieren (\acs{oop}) ermöglicht. Im Anschluss dazu werden ausgewählte Grundsätze der \acs{oop} erklärt. Anschließend werden Inhalte des \ac{dis} Standards, welche in dieser Masterarbeit verwendet wurden, beschrieben. Neben den genannten Grundlagen werden Lösungsansätze erklärt und verglichen, die für die Erstellung einer Klassenhierarchie infrage kommen. Die Lösungsansätze ergeben sich aus verschiedenen Grundideen, welche sich unter anderem in der Erweiterbarkeit, des flexibleren Einsatz und der Komplexität unterscheiden.   Des Weiteren wird der Lösungsansatz und die Implementierung  erklärt, die gewählt wurde. Im Anschluss daran werden die aktuellen Funktionalitäten erklärt und es werden mögliche Erweiterungen dargestellt. Abschließend folgt ein Fazit und ein Ausblick.  
       